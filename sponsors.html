<!doctype html>
<html lang="sv">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sponsorer — Continuous LTR + RTL</title>
</head>

<body>
    <section class="sponsors-section" aria-label="Våra sponsorer">
        <div class="container">
            <h1 class="title" data-i18n="sponsors.title">Våra Sponsorer</h1>

            <!-- LTR track (moves leftward visually, content order left->right) -->
            <div id="wrap-ltr" class="sponsor-wrap" aria-hidden="false">
                <div id="track-ltr" class="sponsor-track ltr" role="list"></div>
            </div>

            <!-- RTL track (same content, moves opposite direction) -->
            <div id="wrap-rtl" class="sponsor-wrap" aria-hidden="false">
                <div id="track-rtl" class="sponsor-track rtl" role="list"></div>
            </div>
        </div>
    </section>

    <!-- <script>
        // CONFIG
        const apiKey = 'xxxx'; // your key
        const folderId = 'xxx';     // your folder

        // Selectors
        const wrapLtr = document.getElementById('wrap-ltr');
        const wrapRtl = document.getElementById('wrap-rtl');
        const trackLtr = document.getElementById('track-ltr');
        const trackRtl = document.getElementById('track-rtl');

        // Fetch images from Drive (only image mimeTypes)
        async function fetchFiles() {
            const q = encodeURIComponent(`'${folderId}' in parents and mimeType contains 'image/' and trashed=false`);
            const url = `https://www.googleapis.com/drive/v3/files?q=${q}&fields=files(id,name,mimeType)&key=${apiKey}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error('Network error fetching Drive files');
            const json = await res.json();
            return (json.files || []).filter(f => f && f.id);
        }

        // Build inner HTML for one set (not duplicated)
        function buildItemsHtml(files) {
            return files.map(f => {
                const src = `https://drive.google.com/thumbnail?id=${f.id}&sz=w1000`;
                const safeName = (f.name || 'sponsor').replace(/"/g, '&quot;').replace(/</g, '&lt;');
                return `<div class="sponsor-item" role="listitem"><img src="${src}" alt="${safeName}"></div>`;
            }).join('');
        }

        // Wait for image elements to decode / load
        function waitForImages(imgElements) {
            const promises = Array.from(imgElements).map(img => {
                if (!img) return Promise.resolve();
                if ('decode' in img) return img.decode().catch(() => undefined);
                return new Promise(res => {
                    if (img.complete) return res();
                    img.addEventListener('load', res);
                    img.addEventListener('error', res);
                });
            });
            return Promise.all(promises);
        }

        // Main
        (async function init() {
            try {
                const files = await fetchFiles();
                if (!files || files.length === 0) {
                    console.warn('No sponsor images found');
                    return;
                }

                // Create single-set HTML and duplicate it for seamless loop.
                const singleHtml = buildItemsHtml(files);

                // Put duplicated content inside both tracks: [items][items]
                trackLtr.innerHTML = singleHtml + singleHtml;
                trackRtl.innerHTML = singleHtml + singleHtml;

                // Optional: adjust a tiny padding at end to avoid cut-off by rounding on some viewports
                // not required but can help visual smoothness:
                // trackLtr.style.paddingRight = getComputedStyle(document.documentElement).getPropertyValue('--gap') || '40px';

                // Wait for all images to decode to avoid layout jumps and then start animation by setting .is-ready
                const imgs = document.querySelectorAll('.sponsor-item img');
                await waitForImages(imgs);

                // Set wrappers to ready: shows them and starts CSS animations
                wrapLtr.classList.add('is-ready');
                wrapRtl.classList.add('is-ready');

                // OPTIONAL: set small negative offsets so they don't match perfectly (already done in CSS via delays),
                // but if you want dynamic offsets relative to track width, you can compute and set style.animationDelay here.

            } catch (err) {
                console.error('Sponsor carousel init error:', err);
                // degrade gracefully: try to show nothing or a fallback message (left out for brevity)
            }
        })();
    </script>-->

    <script>
        // CONFIG — local images
        const SPONSOR_PATH = 'img/sponsors/';
        const sponsorImages = [
            'privtaBarn.png',
            'a2m.png',
            'jcFlytt.png'
            // add more here
        ];

        // Selectors
        const wrapLtr = document.getElementById('wrap-ltr');
        const wrapRtl = document.getElementById('wrap-rtl');
        const trackLtr = document.getElementById('track-ltr');
        const trackRtl = document.getElementById('track-rtl');

        // Build HTML from local images
        function buildItemsHtml(images) {
            return images.map(name => {
                const safeName = name.replace(/[-_]/g, ' ').replace(/\..+$/, '');
                return `
                <div class="sponsor-item" role="listitem">
                    <img src="${SPONSOR_PATH + name}" alt="${safeName}">
                </div>
            `;
            }).join('');
        }

        // Wait for images to load (prevents layout jumps)
        function waitForImages(imgElements) {
            return Promise.all(
                Array.from(imgElements).map(img => {
                    if (img.complete) return Promise.resolve();
                    return new Promise(res => {
                        img.onload = img.onerror = res;
                    });
                })
            );
        }

        // Main
        (async function init() {
            if (!sponsorImages.length) return;

            const singleHtml = buildItemsHtml(sponsorImages);

            // Duplicate for seamless loop
            trackLtr.innerHTML = singleHtml + singleHtml;
            trackRtl.innerHTML = singleHtml + singleHtml;

            await waitForImages(document.querySelectorAll('.sponsor-item img'));

            wrapLtr.classList.add('is-ready');
            wrapRtl.classList.add('is-ready');
        })();
    </script>

</body>

</html>